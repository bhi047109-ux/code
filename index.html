<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Simple Encoder — No IDs Visible</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,Arial;margin:16px;color:#111}
    h1{font-size:20px;margin:0 0 8px}
    .hint{font-size:13px;color:#555;margin-bottom:10px}
    label{display:block;font-weight:700;margin-top:10px}
    textarea,input,button{width:100%;box-sizing:border-box;padding:10px;border-radius:8px;border:1px solid #ccc;margin-top:6px;font-size:15px}
    .row{display:flex;gap:8px;margin-top:10px}
    .row > *{flex:1}
    button{background:#2b6cb0;color:#fff;border:none;cursor:pointer;padding:10px}
    button:disabled{opacity:.5;cursor:not-allowed}
    pre{background:#f7fafc;padding:10px;border-radius:8px;border:1px solid #e2e8f0;min-height:80px;overflow:auto;white-space:pre-wrap;word-break:break-word}
    #banner{display:none;background:#b91c1c;color:#fff;padding:10px;border-radius:8px;margin-bottom:12px;font-weight:700}
  </style>
</head>
<body>
  <div id="banner" role="alert"></div>

  <h1>Simple Encoder</h1>
  <div class="hint">Type a message (any length) and press Encode. To decode, paste a token into Output and press Decode. No usernames are shown on the page.</div>

  <label for="context">Context (optional)</label>
  <input id="context" placeholder="e.g., ICT or BoxHill" />

  <label for="payload">Message to encode (any length)</label>
  <textarea id="payload" rows="6" placeholder="Type your message here"></textarea>

  <div class="row">
    <button id="encodeBtn">Encode</button>
    <button id="decodeBtn">Decode</button>
  </div>

  <label>Output</label>
  <pre id="output">(empty)</pre>

<script>
/*
  Simple static client-side encoder
  - No visible names or passwords in the UI
  - Unlimited characters supported via textarea (note: very large input will increase token size)
  - Uses a single embedded shared passphrase kept out of the visible UI
  - Optional lockdown via lockdown.json (place in same folder)
*/

/* === CONFIG ===
   Replace SHARED_PASSPHRASE value before publishing if you want a different secret.
   NOTE: embedding the passphrase in this file means it's discoverable by viewing source.
*/
const SHARED_PASSPHRASE = "change-this-before-deploy"; // staff should change this

/* === Tiny encoding helpers === */
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const B32_ALPH = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
const B32_MAP = (() => { const m = {}; for (let i=0;i<B32_ALPH.length;i++){ m[B32_ALPH[i]] = i; m[B32_ALPH[i].toLowerCase()] = i; } m["O"] = m["0"]; m["I"] = m["1"]; m["L"] = m["1"]; return m; })();

function toBase32(bytes){
  let bits = 0, value = 0, out = "";
  for (let i=0;i<bytes.length;i++){
    value = (value << 8) | bytes[i];
    bits += 8;
    while (bits >= 5) { out += B32_ALPH[(value >>> (bits - 5)) & 31]; bits -= 5; }
  }
  if (bits > 0) out += B32_ALPH[(value << (5 - bits)) & 31];
  return out;
}

function fromBase32(str){
  let bits = 0, value = 0;
  const out = [];
  for (let i=0;i<str.length;i++){
    const ch = str[i];
    if (!(ch in B32_MAP)) throw new Error("Invalid Base32 character");
    value = (value << 5) | B32_MAP[ch];
    bits += 5;
    if (bits >= 8) { out.push((value >>> (bits - 8)) & 0xFF); bits -= 8; }
  }
  return new Uint8Array(out);
}

function concat(parts){
  let total = 0;
  for (const p of parts) total += p.length;
  const out = new Uint8Array(total);
  let off = 0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

function xorBytes(a, b){
  const out = new Uint8Array(a.length);
  for (let i=0;i<a.length;i++) out[i] = a[i] ^ b[i % b.length];
  return out;
}

const CRC_TABLE = (() => {
  const t = new Uint32Array(256);
  for (let i=0;i<256;i++){
    let c = i;
    for (let j=0;j<8;j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    t[i] = c >>> 0;
  }
  return t;
})();

function crc32(bytes){
  let c = 0xFFFFFFFF >>> 0;
  for (let i=0;i<bytes.length;i++) c = CRC_TABLE[(c ^ bytes[i]) & 0xFF] ^ (c >>> 8);
  return (c ^ 0xFFFFFFFF) >>> 0;
}

function writeU32BE(v){
  return new Uint8Array([(v >>> 24) & 0xFF, (v >>> 16) & 0xFF, (v >>> 8) & 0xFF, v & 0xFF]);
}
function writeU64BE(v){
  const b = new Uint8Array(8);
  const hi = Math.floor(v / 2 ** 32) >>> 0;
  const lo = (v >>> 0);
  b[0] = (hi >>> 24) & 0xFF; b[1] = (hi >>> 16) & 0xFF; b[2] = (hi >>> 8) & 0xFF; b[3] = hi & 0xFF;
  b[4] = (lo >>> 24) & 0xFF; b[5] = (lo >>> 16) & 0xFF; b[6] = (lo >>> 8) & 0xFF; b[7] = lo & 0xFF;
  return b;
}
function readU64BE(b){
  const hi = ((b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3]) >>> 0;
  const lo = ((b[4] << 24) | (b[5] << 16) | (b[6] << 8) | b[7]) >>> 0;
  return hi * 2 ** 32 + lo;
}
function readU32BE(b){ return ((b[0]<<24)|(b[1]<<16)|(b[2]<<8)|b[3]) >>> 0; }

async function sha256(bytes){
  const d = await crypto.subtle.digest('SHA-256', bytes);
  return new Uint8Array(d);
}

/* Envelope:
   header = [nonce(8)][ts(8)][ctxLen(1)][ctxBytes]
   body = cipher
   tail = crc32(header+body)[4]
*/
async function encodeMessage(plainText, passphrase, context=""){
  const plain = textEncoder.encode(plainText);
  const nonce = crypto.getRandomValues(new Uint8Array(8));
  const ts = Date.now();
  const ctxBytes = textEncoder.encode(context || "");
  const seed = await sha256(concat([textEncoder.encode(passphrase), ctxBytes, nonce, writeU64BE(ts)]));
  const cipher = xorBytes(plain, seed);
  const header = concat([nonce, writeU64BE(ts), new Uint8Array([ctxBytes.length]), ctxBytes]);
  const crc = writeU32BE(crc32(concat([header, cipher])));
  const env = concat([header, cipher, crc]);
  return toBase32(env);
}

async function decodeMessage(token, passphrase, context=""){
  const bytes = fromBase32(token.trim());
  let p = 0;
  const nonce = bytes.slice(p, p+8); p += 8;
  const ts = readU64BE(bytes.slice(p,p+8)); p += 8;
  const ctxLen = bytes[p++]; 
  const ctxBytes = bytes.slice(p, p + ctxLen); p += ctxLen;
  const cipherLen = bytes.length - p - 4;
  const cipher = bytes.slice(p, p + cipherLen); p += cipherLen;
  const crcRead = readU32BE(bytes.slice(p, p + 4));
  const decodedCtx = textDecoder.decode(ctxBytes);
  if (decodedCtx !== (context || "")) throw new Error("Context mismatch");
  const header = concat([nonce, writeU64BE(ts), new Uint8Array([ctxLen]), ctxBytes]);
  if (crc32(concat([header, cipher])) !== crcRead) throw new Error("CRC mismatch");
  const seed = await sha256(concat([textEncoder.encode(passphrase), ctxBytes, nonce, writeU64BE(ts)]));
  const plain = xorBytes(cipher, seed);
  return textDecoder.decode(plain);
}

/* === UI wiring === */
const ctxEl = document.getElementById('context');
const payloadEl = document.getElementById('payload');
const outEl = document.getElementById('output');
const encodeBtn = document.getElementById('encodeBtn');
const decodeBtn = document.getElementById('decodeBtn');
const banner = document.getElementById('banner');

encodeBtn.addEventListener('click', async () => {
  try {
    const txt = payloadEl.value;
    if (!txt) { outEl.textContent = '(type a message first)'; return; }
    // unlimited length allowed — but huge messages will produce huge tokens and may be slow
    const token = await encodeMessage(txt, SHARED_PASSPHRASE, ctxEl.value.trim());
    outEl.textContent = token;
  } catch (e) { outEl.textContent = 'Encode error: ' + e.message; }
});

decodeBtn.addEventListener('click', async () => {
  try {
    const tok = outEl.textContent.trim();
    if (!tok) { outEl.textContent = '(paste a token into Output to decode)'; return; }
    const txt = await decodeMessage(tok, SHARED_PASSPHRASE, ctxEl.value.trim());
    outEl.textContent = 'Decoded:\n' + txt;
  } catch (e) { outEl.textContent = 'Decode error: ' + e.message; }
});

/* === Lockdown support ===
   If you place lockdown.json next to this file, the page will disable controls when "active": true.
*/
async function loadLockdown(){
  try {
    const r = await fetch('lockdown.json', { cache: 'no-store' });
    if (!r.ok) return;
    const cfg = await r.json();
    const active = !!cfg.active;
    if (active) {
      banner.style.display = 'block';
      banner.textContent = (cfg.title ? cfg.title + ' — ' : '') + (cfg.message || 'Locked');
      encodeBtn.disabled = true;
      decodeBtn.disabled = true;
      payloadEl.disabled = true;
      ctxEl.disabled = true;
      outEl.textContent = 'LOCKDOWN: Access disabled';
    } else {
      banner.style.display = 'none';
      encodeBtn.disabled = false;
      decodeBtn.disabled = false;
      payloadEl.disabled = false;
      ctxEl.disabled = false;
    }
  } catch (e) {
    // ignore fetch errors; page remains usable
  }
}

loadLockdown();

</script>
</body>
</html>
