<!doctype html>
<!--
  index.html â€” Encoder/Decoder Console (single-file, corrected lockdown)

  Expected files placed next to this index.html:

  1) key.json
     Example:
{
  "alpha": { "A":"01","B":"02","C":"03"," ":"00","a":"21","b":"22","c":"23" },
  "numeric": { "0":"30","1":"31","2":"32"," ":"00" }
}

  2) lockdown.json
     Example:
{
  "active": false,
  "title": "ðŸš¨ SYSTEM LOCKDOWN ðŸš¨",
  "message": "Access denied until lockdown is lifted",
  "refreshSeconds": 10
}

  Notes:
  - Start gate code: 1234 (blocks everything until entered).
  - This file fixes lockdown logic:
    * window.LOCKCFG is authoritative and updated from lockdown.json.
    * When LOCKCFG.active === true the full-screen lockdown overlay appears,
      UI is blocked (pointer-events, keyboard/tab stops), and a sustained loud siren runs.
    * When LOCKCFG.active === false the overlay hides and siren stops cleanly.
  - Use only vanilla JS. Drop this file into your static host with key.json and lockdown.json.
-->

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Encoder/Decoder Console â€” Lockdown Fixed</title>
<style>
  :root{
    --bg:#071017; --panel:linear-gradient(180deg,#071017cc,#0b1620cc);
    --muted:#9fb4bc; --fg:#e8f6f7; --accent:#39d1ff; --accent-2:#8a5cff; --danger:#ff4d6d;
  }
  body.light{--bg:#f6f9fb;--panel:linear-gradient(180deg,#fff,#f2f6f9);--muted:#51646f;--fg:#042028;--accent:#0b84ff;--accent-2:#8a5cff;}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#030406);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  #matrix{position:fixed;inset:0;z-index:0;pointer-events:none;opacity:0;transition:opacity .4s}
  #matrix.active{opacity:0.9}
  .container{position:relative;z-index:2;max-width:1150px;margin:20px auto;padding:18px;border-radius:12px;background:var(--panel);box-shadow:0 8px 40px rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.03)}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{margin:0;font-size:20px} .hint{color:var(--muted);font-size:13px}

  /* START GATE */
  .startgate{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,.7),rgba(0,0,0,.85));z-index:10000}
  .gateBox{width:360px;background:rgba(255,255,255,.02);padding:18px;border-radius:12px;text-align:center;border:1px solid rgba(255,255,255,.03)}
  .gateBox input{font-size:20px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,.04);width:100%;text-align:center;background:transparent;color:var(--fg)}
  .gateBox button{margin-top:12px;padding:10px 14px;border-radius:8px;border:none;background:var(--accent);color:#021217;cursor:pointer;font-weight:700}

  /* LOCKDOWN overlay (full-screen) */
  .lockdown{position:fixed;inset:0;z-index:99999;display:none;align-items:center;justify-content:center;background:radial-gradient(circle at 30% 20%, rgba(138,92,255,.12), rgba(0,0,0,.95));color:#fff;overflow:hidden}
  .lockdown.active{display:flex}
  .lockinner{width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;padding:24px;box-sizing:border-box}
  .lockcard{max-width:920px;padding:26px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px solid rgba(255,255,255,.04);text-align:center}
  .lockcard h2{color:var(--accent-2);margin:0 0 8px}
  .lockcard p{color:#f7f7f7;margin:0 0 12px;font-size:16px}
  .lock-siren { width:44px;height:44px;border-radius:50%;background:var(--danger);box-shadow:0 0 22px var(--danger),0 0 60px rgba(255,56,96,.18); display:inline-block; }
  .lock-flash { animation: flash 800ms infinite; }
  @keyframes flash { 0%{transform:scale(1);opacity:1}50%{transform:scale(1.5);opacity:.5}100%{transform:scale(1);opacity:1} }

  /* basic UI layout */
  .row{display:flex;gap:12px;align-items:flex-start}
  .col{flex:1;min-width:0}
  .panel{background:rgba(255,255,255,.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.02)}
  label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
  select,input[type=text],textarea{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,.04);background:transparent;color:var(--fg);resize:vertical}
  textarea{min-height:140px;max-height:380px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:linear-gradient(180deg,var(--accent),var(--accent-2));color:#021217;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.04);color:var(--fg)}
  .status{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;color:var(--muted);font-size:13px}
  .status .pill{background:rgba(255,255,255,.02);padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,.02)}
  .history{max-height:320px;overflow:auto;padding:6px;display:flex;flex-direction:column;gap:8px}
  .hrow{display:flex;gap:8px;align-items:flex-start;background:rgba(255,255,255,.01);padding:8px;border-radius:8px}
  .htime{color:var(--muted);min-width:130px;font-size:12px}
  .htext{flex:1;font-family:monospace;font-size:13px;color:var(--fg);white-space:pre-wrap;word-break:break-word}
  .glitch{position:relative;color:var(--accent-2);text-shadow:0 0 6px rgba(138,92,255,.5)}
  .glitch::after,.glitch::before{content:attr(data-text);position:absolute;left:0;top:0;width:100%;opacity:.6;mix-blend-mode:screen}
  .glitch::before{color:#39d1ff;transform:translate(2px,-1px);clip-path:inset(0 0 60% 0)}
  .glitch::after{color:#ff6fb5;transform:translate(-2px,1px);clip-path:inset(40% 0 0 0)}
  @media(max-width:960px){.row{flex-direction:column}header{flex-direction:column;align-items:flex-start}}
  button:focus,input:focus,textarea:focus,select:focus{outline:2px solid rgba(57,209,255,.14);outline-offset:2px}
  footer{margin-top:12px;color:var(--muted);font-size:12px;text-align:center}
</style>
</head>
<body>
  <canvas id="matrix" aria-hidden="true"></canvas>

  <!-- Lockdown overlay -->
  <div id="lockdown" class="lockdown" aria-hidden="true" role="alert">
    <div class="lockinner" id="lockinner">
      <div class="lockcard" role="document" aria-live="assertive">
        <div style="display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:12px">
          <div id="lockSirenLight" class="lock-siren" aria-hidden="true"></div>
          <h2 id="lockTitle">SYSTEM LOCKDOWN</h2>
        </div>
        <p id="lockMessage">Access denied until lockdown is lifted</p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:12px;align-items:center;">
          <button class="btn" id="shakeLock">Shake Lockdown</button>
          <button class="btn ghost" id="refreshLock">Refresh</button>
          <label style="color:var(--muted);display:flex;align-items:center;gap:8px;margin-left:12px">
            <input id="sirenVol" type="range" min="0" max="1" step="0.05" value="0.5"> Volume
          </label>
        </div>
      </div>
    </div>
  </div>

  <!-- Start gate -->
  <div id="startGate" class="startgate" role="dialog" aria-modal="true" aria-hidden="false">
    <div class="gateBox" role="document" aria-label="Start gate">
      <h2>Enter 4â€‘digit code to start</h2>
      <p>Type the 4-digit code to unlock the console</p>
      <input id="gateInput" inputmode="numeric" maxlength="4" placeholder="----" aria-label="Start code" />
      <button id="gateOpen">Open</button>
      <p style="margin-top:8px;color:var(--muted);font-size:13px">Start gate blocks the page until the correct code is entered.</p>
    </div>
  </div>

  <div class="container" id="app" aria-hidden="true">
    <header>
      <div>
        <h1>Encoder / Decoder Console</h1>
        <div class="hint">Loads key.json & lockdown.json â€” Start gate required</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <div id="profileStatus" class="hint">Ready</div>
        <button class="btn ghost" id="toggleTheme">Theme</button>
        <button class="btn ghost" id="toggleMatrix">Matrix</button>
        <button class="btn ghost" id="toggleGlitch">Glitch</button>
        <button class="btn ghost" id="sirenToggle">Siren</button>
      </div>
    </header>

    <main>
      <div class="row">
        <div class="col panel" style="z-index:2">
          <label for="channelSelect">Channel</label>
          <select id="channelSelect"><option>Loading key.jsonâ€¦</option></select>

          <label for="delimiter" style="margin-top:10px">Delimiter</label>
          <input id="delimiter" type="text" value=" " />

          <label for="inputArea" style="margin-top:10px">Input</label>
          <textarea id="inputArea" placeholder="Type or paste text to encode/decode..."></textarea>

          <div class="controls">
            <button class="btn" id="encodeBtn">Encode</button>
            <button class="btn" id="decodeBtn">Decode</button>
            <button class="btn ghost" id="copyBtn">Copy Output</button>
            <button class="btn ghost" id="scrambleBtn">Scramble Output</button>
            <button class="btn ghost" id="randomBtn">Random Test</button>
            <button class="btn ghost" id="exportBtn">Export History</button>
            <button class="btn ghost" id="shakeBtn">Shake Lockdown</button>
          </div>

          <div class="status" aria-live="polite">
            <div class="pill">Coverage: <span id="coverage">-</span></div>
            <div class="pill">Tokens/Len: <span id="tokens">-</span></div>
            <div class="pill">Speed: <span id="speed">-</span></div>
            <div class="pill">Entropy: <span id="entropy">-</span></div>
          </div>
        </div>

        <div class="col panel" style="z-index:2;max-width:520px;min-width:260px">
          <label>Output</label>
          <pre id="outputBox" style="min-height:160px;white-space:pre-wrap"></pre>

          <div style="margin-top:8px" class="hint">History</div>
          <div class="history" id="historyPanel"></div>
        </div>
      </div>
    </main>

    <footer class="hint">Single-file app â€¢ No external libs</footer>
  </div>

<script>
/* Full app logic with corrected, loud lockdown behavior.
   Key points fixed:
   - window.LOCKCFG is created and used as the single source of truth.
   - loadLockdownJson updates window.LOCKCFG and calls applyLockdown().
   - applyLockdown shows/hides overlay, sets aria-hidden, disables UI interactions,
     traps focus, starts/stops a sustained loud siren.
   - Shake Lockdown performs a visible shake and a short loud siren pulse.
*/

/* --- Helpers --- */
const $ = id => document.getElementById(id);
const now = () => performance.now();
const isoNow = () => new Date().toISOString();

function hexOfChar(ch){
  const u = new TextEncoder().encode(ch);
  return Array.from(u).map(b => b.toString(16).padStart(2,'0')).join('');
}
function charFromHex(hex){
  if (!hex) return '';
  const bytes = hex.match(/.{1,2}/g);
  if (!bytes) return '?';
  try { return new TextDecoder().decode(new Uint8Array(bytes.map(h=>parseInt(h,16)))); } catch(e){ return '?'; }
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function downloadFile(filename, content, type='application/json'){ const blob=new Blob([content],{type}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }

/* --- State --- */
window.KEYMAP = {};                   // loaded from key.json
window.LOCKCFG = { active:false };    // authoritative lockdown state (updated by loadLockdownJson)
let HISTORY = [];
let matrixOn = false, matrixAnim = null;
let glitchOn = false;
let themeLight = false;

/* --- Audio state for loud siren --- */
window.__SIREN = window.__SIREN || { ctx:null, gain:null, oscs:[], modId:null };

/* Create / reuse audio context */
function ensureAudio(){
  try {
    if (!window.__SIREN.ctx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return null;
      window.__SIREN.ctx = new Ctx();
    }
    return window.__SIREN.ctx;
  } catch(e) { return null; }
}

/* Start sustained loud siren (keeps running until stopSiren) */
function startSiren(volume=0.6){
  const ctx = ensureAudio();
  if (!ctx) return;
  stopSiren(); // ensure clean start
  const s = window.__SIREN;
  s.gain = ctx.createGain();
  s.gain.gain.value = 0.00001;
  s.gain.connect(ctx.destination);
  const baseFreqs = [420, 640, 920];
  s.oscs = baseFreqs.map((f, i) => {
    const o = ctx.createOscillator();
    o.type = i===0 ? 'sine' : (i===1 ? 'triangle' : 'sawtooth');
    o.frequency.value = f;
    o.connect(s.gain);
    try { o.start(); } catch(e){}
    return o;
  });
  // ramp gain to target (clamped)
  const target = Math.min(1.2, (volume || 0.6)); // allow louder pulses
  try { s.gain.gain.linearRampToValueAtTime(target, ctx.currentTime + 0.05); } catch(e){}
  // modulate frequencies for siren tone
  s.modId = setInterval(() => {
    const t = Date.now()/160;
    for (let i=0;i<s.oscs.length;i++){
      const base = baseFreqs[i];
      const f = base + Math.sin(t + i) * (120 + i*40);
      try { s.oscs[i].frequency.setTargetAtTime(f, ctx.currentTime, 0.03); } catch(e){}
    }
  }, 50);
}

/* Stop siren cleanly */
function stopSiren(){
  const s = window.__SIREN;
  if (s.modId) { clearInterval(s.modId); s.modId = null; }
  if (s.oscs && s.oscs.length){
    for(const o of s.oscs){ try { o.stop(); } catch(e){} try { o.disconnect(); } catch(e){} }
    s.oscs = [];
  }
  if (s.gain){ try { s.gain.disconnect(); } catch(e){} s.gain = null; }
  // keep audio context alive to avoid re-permission prompts
}

/* Short siren pulse (non-sustained) */
function pulseSiren(volume=1.0, duration=1200){
  const ctx = ensureAudio();
  if (!ctx) return;
  // create a temporary set of oscillators and stop them after duration
  const gain = ctx.createGain(); gain.gain.value = 0.00001; gain.connect(ctx.destination);
  const freqs = [480, 720, 1000];
  const oscs = freqs.map((f,i)=>{
    const o = ctx.createOscillator(); o.type = i===0 ? 'sine' : (i===1 ? 'triangle' : 'sawtooth'); o.frequency.value = f; o.connect(gain); try{o.start();}catch(e){}
    return o;
  });
  try { gain.gain.linearRampToValueAtTime(Math.min(1.5,volume), ctx.currentTime + 0.03); } catch(e){}
  // modulate slightly
  const id = setInterval(()=> {
    const t = Date.now()/150;
    for (let i=0;i<oscs.length;i++){
      try { oscs[i].frequency.setTargetAtTime(freqs[i] + Math.sin(t + i)*80, ctx.currentTime, 0.02); } catch(e){}
    }
  }, 50);
  setTimeout(()=> {
    clearInterval(id);
    for(const o of oscs){ try{o.stop();}catch(e){} try{o.disconnect();}catch(e){} }
    try { gain.disconnect(); } catch(e){}
  }, duration);
}

/* --- DOM refs --- */
const startGate = $('startGate'), gateInput = $('gateInput'), gateOpen = $('gateOpen');
const app = $('app'), channelSelect = $('channelSelect'), delimiter = $('delimiter'), inputArea = $('inputArea');
const encodeBtn = $('encodeBtn'), decodeBtn = $('decodeBtn'), outputBox = $('outputBox');
const copyBtn = $('copyBtn'), scrambleBtn = $('scrambleBtn'), randomBtn = $('randomBtn'), exportBtn = $('exportBtn');
const historyPanel = $('historyPanel'), coverage = $('coverage'), tokens = $('tokens'), speed = $('speed'), entropy = $('entropy');
const toggleTheme = $('toggleTheme'), toggleMatrix = $('toggleMatrix'), toggleGlitch = $('toggleGlitch'), sirenToggle = $('sirenToggle');
const shakeBtn = $('shakeBtn'), lockdownEl = $('lockdown'), lockTitle = $('lockTitle'), lockMessage = $('lockMessage');
const lockSirenLight = $('lockSirenLight'), shakeLock = $('shakeLock'), refreshLock = $('refreshLock'), sirenVol = $('sirenVol');
const profileStatus = $('profileStatus'), matrixCanvas = $('matrix');

/* Start gate behavior */
function openApp(){ startGate.style.display='none'; startGate.setAttribute('aria-hidden','true'); app.setAttribute('aria-hidden','false'); app.style.opacity=1; }
gateOpen.addEventListener('click', ()=> {
  const v = (gateInput.value||'').trim();
  if (v === '1234') openApp();
  else { gateInput.value=''; gateInput.focus(); alert('Incorrect code'); }
});
gateInput.addEventListener('input', ()=> gateInput.value = gateInput.value.replace(/[^\d]/g,'').slice(0,4));
gateInput.addEventListener('keyup', e => { if (e.key === 'Enter') gateOpen.click(); });
setTimeout(()=> gateInput.focus(), 200);

/* Load key.json and populate channels */
async function loadKeyJson(){
  try {
    const r = await fetch('key.json',{cache:'no-store'});
    if (!r.ok) throw new Error('key.json not found');
    window.KEYMAP = await r.json();
    populateChannels();
    profileStatus.textContent = 'Loaded key.json';
  } catch(e){
    window.KEYMAP = {};
    channelSelect.innerHTML = '<option>(no key.json)</option>';
    profileStatus.textContent = 'No key.json';
    console.warn('loadKeyJson', e);
  }
}
function populateChannels(){
  channelSelect.innerHTML = '';
  const names = Object.keys(window.KEYMAP).sort();
  if (!names.length){ const o=document.createElement('option'); o.textContent='(no channels)'; channelSelect.appendChild(o); return; }
  for(const n of names){ const opt=document.createElement('option'); opt.value=n; opt.textContent=n; channelSelect.appendChild(opt); }
}

/* Load lockdown.json and apply */
let lockdownPollId = null;
async function loadLockdownJson(){
  try {
    const r = await fetch('lockdown.json',{cache:'no-store'});
    if (!r.ok) throw new Error('no lockdown.json');
    const cfg = await r.json();
    // ensure window.LOCKCFG exists and is authoritative
    window.LOCKCFG = Object.assign({active:false,title:'',message:'',refreshSeconds:120}, cfg);
    applyLockdown(window.LOCKCFG);
    if (lockdownPollId) clearInterval(lockdownPollId);
    lockdownPollId = setInterval(loadLockdownJson, (window.LOCKCFG.refreshSeconds||120)*1000);
  } catch(e){
    // missing lockdown.json => default unlocked
    window.LOCKCFG = { active:false, title:'', message:'', refreshSeconds:120 };
    applyLockdown(window.LOCKCFG);
  }
}

/* Apply lockdown state (show overlay, trap input, siren) */
function applyLockdown(cfg){
  const active = !!(cfg && cfg.active);
  if (active){
    // show overlay
    lockdownEl.classList.add('active');
    lockdownEl.setAttribute('aria-hidden','false');
    lockTitle.textContent = cfg.title || 'SYSTEM LOCKDOWN';
    lockMessage.textContent = cfg.message || 'Access denied until lockdown is lifted';
    // visually and interactively disable app
    app.style.filter = 'blur(4px) grayscale(.4)';
    // pointer-events none prevents clicks but not keyboard focus; make inert via inert attribute and tabindex management
    app.setAttribute('aria-hidden','true');
    setInert(true);
    // start sustained loud siren at volume from slider
    const vol = Number(sirenVol.value || 0.6);
    lockSirenLight.style.display = 'inline-block';
    lockSirenLight.classList.add('lock-flash');
    startSiren(Math.min(1.2, vol));
  } else {
    // hide overlay
    lockdownEl.classList.remove('active');
    lockdownEl.setAttribute('aria-hidden','true');
    app.style.filter = '';
    app.setAttribute('aria-hidden','false');
    setInert(false);
    // stop siren, clear visuals
    lockSirenLight.classList.remove('lock-flash');
    lockSirenLight.style.display = 'none';
    stopSiren();
  }
}

/* setInert toggles focusability on elements under #app to prevent keyboard use while locked.
   This is a lightweight inert shim for the static page.
*/
function setInert(inert){
  const focusables = app.querySelectorAll('button,a,input,select,textarea,[tabindex]');
  for(const el of focusables){
    if (inert){
      // store previous tabindex
      if (!el.hasAttribute('data-prev-tabindex')) el.setAttribute('data-prev-tabindex', el.getAttribute('tabindex') || '');
      el.setAttribute('tabindex', '-1');
      el.setAttribute('aria-hidden', 'true');
    } else {
      const prev = el.getAttribute('data-prev-tabindex');
      if (prev === '' || prev === null) el.removeAttribute('tabindex'); else el.setAttribute('tabindex', prev);
      el.removeAttribute('data-prev-tabindex');
      el.removeAttribute('aria-hidden');
    }
  }
}

/* Shake lockdown: visible shake + short pulse siren */
function shakeLockAction(){
  // flash overlay and pulse siren
  const origActive = !!(window.LOCKCFG && window.LOCKCFG.active);
  // always show a temporary visual even if not fully active
  lockdownEl.classList.add('active');
  lockdownEl.setAttribute('aria-hidden','false');
  lockSirenLight.style.display = 'inline-block';
  lockSirenLight.classList.add('lock-flash');
  // perform shake animation
  const el = document.querySelector('.lockcard');
  if (el) el.animate([
    { transform: 'translateY(0) rotate(0)' },
    { transform: 'translateY(-14px) rotate(-1deg)' },
    { transform: 'translateY(10px) rotate(1deg)' },
    { transform: 'translateY(0) rotate(0)' }
  ], { duration: 800, easing:'ease-in-out' });
  // short loud pulse
  pulseSiren(1.2, 1200);
  // revert to previous lockdown state after pulse
  setTimeout(()=> {
    if (!origActive){
      lockdownEl.classList.remove('active');
      lockdownEl.setAttribute('aria-hidden','true');
      lockSirenLight.classList.remove('lock-flash');
      lockSirenLight.style.display = 'none';
    } else {
      // keep visual if original active
      lockSirenLight.classList.add('lock-flash');
    }
  }, 1400);
}

/* --- Encode / Decode logic --- */
function coveragePct(channel){
  const map = (window.KEYMAP && window.KEYMAP[channel]) || {};
  return Math.round((Object.keys(map).length || 0) / 256 * 100);
}
function encode(channel, delim, text){
  const t0 = now();
  const map = (window.KEYMAP && window.KEYMAP[channel]) || {};
  const outTokens = [];
  for(const ch of Array.from(text)){
    if (Object.prototype.hasOwnProperty.call(map, ch)) outTokens.push(map[ch]);
    else outTokens.push(`${channel}_UNK_${hexOfChar(ch)}`);
  }
  return { out: outTokens.join(delim), tokens: outTokens, elapsed: now()-t0 };
}
function decode(channel, delim, tokenString){
  const t0 = now();
  const map = (window.KEYMAP && window.KEYMAP[channel]) || {};
  const rev = {};
  for(const k in map) rev[map[k]] = k;
  const toks = tokenString ? tokenString.split(delim) : [];
  const chars = [];
  for(const tk of toks){
    if (tk.startsWith(channel + '_UNK_')) chars.push(charFromHex(tk.substring((channel + '_UNK_').length)));
    else if (rev[tk] !== undefined) chars.push(rev[tk]);
    else chars.push('?');
  }
  return { text: chars.join(''), toks, elapsed: now()-t0 };
}

/* --- UI wiring --- */
encodeBtn.addEventListener('click', ()=>{
  const ch = channelSelect.value; const d = delimiter.value || ' '; const txt = inputArea.value || '';
  if (!ch || !(window.KEYMAP && window.KEYMAP[ch])) { alert('Choose a valid channel'); return; }
  const r = encode(ch,d,txt);
  outputBox.textContent = r.out;
  coverage.textContent = coveragePct(ch) + '%';
  tokens.textContent = `${r.tokens.length} / ${r.out.length}`;
  speed.textContent = `${Math.round(r.elapsed)}ms`;
  entropy.textContent = estimateEntropy(r.out).toFixed(2);
  HISTORY.unshift({ ts: isoNow(), action:'encode', channel:ch, ms:Math.round(r.elapsed), input:txt, output:r.out });
  renderHistory();
  applyGlitch();
});

decodeBtn.addEventListener('click', ()=>{
  const ch = channelSelect.value; const d = delimiter.value || ' '; const tok = outputBox.textContent || '';
  if (!ch || !(window.KEYMAP && window.KEYMAP[ch])) { alert('Choose a valid channel'); return; }
  const r = decode(ch,d,tok);
  inputArea.value = r.text;
  coverage.textContent = coveragePct(ch) + '%';
  tokens.textContent = `${r.toks.length} / ${tok.length}`;
  speed.textContent = `${Math.round(r.elapsed)}ms`;
  entropy.textContent = estimateEntropy(tok).toFixed(2);
  HISTORY.unshift({ ts: isoNow(), action:'decode', channel:ch, ms:Math.round(r.elapsed), tokens:r.toks.length, outputText:r.text });
  renderHistory();
  applyGlitch();
});

copyBtn.addEventListener('click', async ()=>{
  const txt = outputBox.textContent || '';
  if (!txt) return;
  try { await navigator.clipboard.writeText(txt); profileStatus.textContent = 'Copied'; } catch(e){ profileStatus.textContent = 'Copy failed'; }
});

scrambleBtn.addEventListener('click', ()=>{
  const d = delimiter.value || ' '; const t = outputBox.textContent || '';
  if (!t) return;
  const s = shuffle(t.split(d)).join(d); outputBox.textContent = s;
  HISTORY.unshift({ ts: isoNow(), action:'scramble', tokens:s.split(d).length }); renderHistory();
});

randomBtn.addEventListener('click', ()=> {
  const samples = ['hello world','secret code','play time','box hill lab','the quick brown fox','lorem ipsum','TEST123','ðŸ˜€ smile'];
  inputArea.value = samples[Math.floor(Math.random()*samples.length)];
});

exportBtn.addEventListener('click', ()=> downloadFile(`history_${new Date().toISOString().replace(/[:.]/g,'-')}.json`, JSON.stringify(HISTORY, null, 2)));

toggleTheme.addEventListener('click', ()=> { themeLight = !themeLight; document.body.classList.toggle('light', themeLight); });
toggleGlitch.addEventListener('click', ()=> { glitchOn = !glitchOn; applyGlitch(); });
toggleMatrix.addEventListener('click', ()=> { if (!matrixOn) startMatrix(); else stopMatrix(); });

sirenToggle.addEventListener('click', ()=> {
  // toggle sustained siren irrespective of lockdown
  if (window.__SIREN.oscs && window.__SIREN.oscs.length){ stopSiren(); lockSirenLight.style.display='none'; } else { startSiren(Number(sirenVol.value||0.6)); lockSirenLight.style.display='inline-block'; }
});

shakeBtn.addEventListener('click', ()=> shakeLockAction());
shakeLock.addEventListener('click', ()=> shakeLockAction());
refreshLock.addEventListener('click', ()=> loadLockdownJson());

sirenVol.addEventListener('input', ()=> {
  const v = Number(sirenVol.value || 0.6);
  if (window.__SIREN.oscs && window.__SIREN.oscs.length){
    // adjust gain quickly
    try { window.__SIREN.gain.gain.setTargetAtTime(Math.min(1.2,v), window.__SIREN.ctx.currentTime, 0.02); } catch(e){}
  }
});

/* --- Glitch effect --- */
function applyGlitch(){
  if (glitchOn){ outputBox.classList.add('glitch'); outputBox.setAttribute('data-text', outputBox.textContent); outputBox.animate([{opacity:1},{opacity:0.7},{opacity:1}],{duration:420,iterations:1}); }
  else { outputBox.classList.remove('glitch'); outputBox.removeAttribute('data-text'); }
}

/* --- History --- */
function renderHistory(){
  historyPanel.innerHTML = '';
  for(const h of HISTORY.slice(0,200)){
    const r = document.createElement('div'); r.className='hrow';
    const t = document.createElement('div'); t.className='htime'; t.textContent = new Date(h.ts).toLocaleString();
    const txt = document.createElement('div'); txt.className='htext';
    let s = h.action.toUpperCase();
    if (h.channel) s += ' â€¢ ' + h.channel;
    if (h.input) s += ' â€¢ ' + (h.input.length > 80 ? h.input.slice(0,77)+'â€¦' : h.input);
    txt.textContent = s;
    r.appendChild(t); r.appendChild(txt); historyPanel.appendChild(r);
  }
}

/* --- Matrix background --- */
const MC = matrixCanvas; let matCtx=null, cols=0, fontSize=16, drops=[];
function startMatrix(){
  MC.classList.add('active'); matrixOn = true; MC.width = window.innerWidth; MC.height = window.innerHeight; matCtx = MC.getContext('2d'); fontSize = 16; cols = Math.floor(MC.width / fontSize); drops = Array.from({length:cols}, ()=>1);
  (function draw(){ if (!matrixOn) return; matCtx.fillStyle = 'rgba(0,0,0,0.12)'; matCtx.fillRect(0,0,MC.width,MC.height); matCtx.font = fontSize + 'px monospace'; for(let i=0;i<cols;i++){ const text = String.fromCharCode(33 + Math.random()*94); matCtx.fillStyle = `rgba(57,255,140,${0.15 + Math.random()*0.85})`; matCtx.fillText(text, i*fontSize, drops[i]*fontSize); if (drops[i]*fontSize > MC.height && Math.random() > 0.975) drops[i]=0; drops[i]++; } matrixAnim = requestAnimationFrame(draw); })();
}
function stopMatrix(){ MC.classList.remove('active'); matrixOn = false; if (matrixAnim) cancelAnimationFrame(matrixAnim); if (matCtx) matCtx.clearRect(0,0,MC.width,MC.height); }

/* --- Entropy estimate --- */
function estimateEntropy(s){ if(!s) return 0; const f={}; for(const c of s) f[c] = (f[c]||0)+1; let H=0; const L=s.length; for(const k in f){ const p = f[k]/L; H -= p*Math.log2(p); } return H; }

/* --- Init sequence --- */
async function init(){
  // hide main app until start gate opens
  app.setAttribute('aria-hidden','true'); app.style.opacity = 0;
  await loadKeyJson();
  await loadLockdownJson();
  delimiter.value = delimiter.value || ' ';
  channelSelect.addEventListener('change', ()=> profileStatus.textContent = `Channel: ${channelSelect.value}`);
  window.addEventListener('resize', ()=> { if (matrixOn){ MC.width = window.innerWidth; MC.height = window.innerHeight; } });
}
init();

/* --- network loaders (defined after init to use functions above) --- */
async function loadKeyJson(){
  try {
    const r = await fetch('key.json', { cache:'no-store' });
    if (!r.ok) throw new Error('key.json missing');
    window.KEYMAP = await r.json();
    populateChannels();
  } catch(e){
    window.KEYMAP = {}; channelSelect.innerHTML = '<option>(no key.json)</option>'; console.warn('loadKeyJson', e);
  }
}
function populateChannels(){
  channelSelect.innerHTML = '';
  const names = Object.keys(window.KEYMAP).sort();
  if (!names.length){ const o=document.createElement('option'); o.textContent='(no channels)'; channelSelect.appendChild(o); return; }
  for(const n of names){ const o=document.createElement('option'); o.value=n; o.textContent=n; channelSelect.appendChild(o); }
}

async function loadLockdownJson(){
  try {
    const r = await fetch('lockdown.json', { cache:'no-store' });
    if (!r.ok) throw new Error('lockdown.json missing');
    const cfg = await r.json();
    // ensure global LOCKCFG gets updated and applied
    window.LOCKCFG = Object.assign({active:false,title:'',message:'',refreshSeconds:120}, cfg);
    applyLockdown(window.LOCKCFG);
    if (lockdownPollId) clearInterval(lockdownPollId);
    lockdownPollId = setInterval(loadLockdownJson, (window.LOCKCFG.refreshSeconds || 120) * 1000);
  } catch(e){
    window.LOCKCFG = { active:false, title:'', message:'', refreshSeconds:120 };
    applyLockdown(window.LOCKCFG);
  }
}

/* --- keyboard shortcuts for dev/testing --- */
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'l'){
    // toggle lockdown state and write it to window.LOCKCFG for testing
    window.LOCKCFG = window.LOCKCFG || {};
    window.LOCKCFG.active = !window.LOCKCFG.active;
    applyLockdown(window.LOCKCFG);
  }
});

/* --- Shake Lock button binding --- */
shakeLock.addEventListener('click', shakeLockAction);

/* --- Refresh Lock binding --- */
refreshLock.addEventListener('click', () => loadLockdownJson());

/* --- ensure overlay state on initial load if lockdown.json indicated active --- */
window.addEventListener('load', ()=> {
  // show app only after start gate is opened by user; start gate controls reveal
  // but the lockdown overlay should be applied immediately if LOCKCFG.active loaded earlier
  if (window.LOCKCFG && window.LOCKCFG.active) applyLockdown(window.LOCKCFG);
});

/* end script */
</script>
</body>
</html>
